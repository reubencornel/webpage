* Cracking the Oyster

** Introduction

This chapter tries to draw our attention to necessity of acquiring and
understanding the need for us to gain comprehensive information about
the problem domain and how that knowledge can lead us towards
developing elegant solutions. In other words he is talking about how 


** The mysterious sort function

Bentley starts up by describing a problem where a programmer told him
that he wanted to write a sort for a disk file. But then in the
illustration Bentley provides a solution immediately, in the form of a
disk based merge sort. This response does not enthuse the programmer.
Bentley goes back and questions him about the need for the sort
function, the inputs, the outputs and the constraints that are to be
placed on that function. 

Based on the programmers description he summarizes the
requirements. I liked the very objective manner in which this problem
was discussed and the requirements explained. I have listed the
requirements belows

<i>Input:</i> The file contains n positive integers where n =
10<sup>7</sup>. It is an error if any integer occurs twice in the 
input, ergo all integers in the input are unique. No other data is
associated with the integer.

<i>Output:</i> The input integers sorted in ascending order.

<i>Constraints:</i> Roughly about a megabyte of storage in main 
memory and very short run time.

Things I would like to make a note of from here is that when talking
about an input to a function define the characteristics of the data
that is the type, conditions that invalidate the data, constraints on
the data and other contextual information.

Constraints could mainly be space and time but in other cases we might
also have to consider robustness, reliability and ability to handle
failure.

** Program Design

Bentley discusses a number of approaches to the problem. The first one
being a on disk based merge sort, the pros of using this approach is
that its quick. But then it might take a few days to code it up. 

The second approach is a multiple pass sort algorithm, he discusses
that a file and be read in multiple times in chunks sorted in memory
and then later be merged back. The major drawback of this is that it
requires as many as forty passes for the specification he has
mentioned. He then comes to the point that the best approach to this
problem would be one where there the input is read once, sorted in
memory and the output is written to the file once. 

Based on this and the general characteristics of the data he arrives
at uses a bitmap or a bit vector representation. The whole idea is
that the individual bits in the memory could be used to represent
individual phone numbers. In effect he is doing a sort of counting
sort.

** Principles

I'll use this section to list out ideas that I learned from this
article

<ul>
	<li> Careful analysis of a problem can help identify elegant
	solutions.
	<li> Define the problem as unambiguously as possible
	<li> In most cases reducing space requirements reduces runtime
	<li> Design simple solutions.
</ul>

<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Real World Haskell -  Bryan O'Sullivan, Don Stewart, and John Goerzen</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2011-08-28 23:28:36 PDT"/>
<meta name="author" content="Reuben Francis Cornel"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" type="text/css" href="orgstyle.css" />
<link rel="stylesheet" type="text/css" href="orgstyle.css" />
<script type="text/javascript" src="'org-info.js'"></script>
<script type="text/javascript" >
<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "toc");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">

<h1 class="title">Real World Haskell -  Bryan O'Sullivan, Don Stewart, and John Goerzen</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Real World Haskell </a></li>
<li><a href="#sec-2">2 Types and functions </a>
<ul>
<li><a href="#sec-2.1">2.1 Why care about types </a></li>
<li><a href="#sec-2.2">2.2 Haskell's type system </a>
<ul>
<li><a href="#sec-2.2.1">2.2.1 Strong type </a></li>
<li><a href="#sec-2.2.2">2.2.2 Static type </a></li>
<li><a href="#sec-2.2.3">2.2.3 Type infereence </a></li>
</ul>
</li>
<li><a href="#sec-2.3">2.3 What to expect from the type system </a>
<ul>
<li><a href="#sec-2.3.1">2.3.1 Some basic common types </a></li>
<li><a href="#sec-2.3.2">2.3.2 Function application </a></li>
<li><a href="#sec-2.3.3">2.3.3 Lists </a></li>
<li><a href="#sec-2.3.4">2.3.4 Tuples </a></li>
<li><a href="#sec-2.3.5">2.3.5 Exercise Solutions </a></li>
</ul>
</li>
<li><a href="#sec-2.4">2.4 Functions over Lists and tuples </a>
<ul>
<li><a href="#sec-2.4.1">2.4.1 List Functions </a></li>
<li><a href="#sec-2.4.2">2.4.2 Tuple Functions </a></li>
<li><a href="#sec-2.4.3">2.4.3 Function Types and purity </a></li>
</ul>
</li>
<li><a href="#sec-2.5">2.5 Haskell source files and writing simple functions </a>
<ul>
<li><a href="#sec-2.5.1">2.5.1 Just what is a variable anyway </a></li>
</ul>
</li>
<li><a href="#sec-2.6">2.6 Polymorphism in haskell </a></li>
<li><a href="#sec-2.7">2.7 Functions with more that one argument </a></li>
</ul>
</li>
<li><a href="#sec-3">3 Data types and stream lining functions </a>
<ul>
<li><a href="#sec-3.1">3.1 Defining new data types </a>
<ul>
<li><a href="#sec-3.1.1">3.1.1 Type synonyms </a></li>
<li><a href="#sec-3.1.2">3.1.2 Algebraic Data types </a></li>
</ul>
</li>
<li><a href="#sec-3.2">3.2 Pattern Matching </a>
<ul>
<li><a href="#sec-3.2.1">3.2.1 Construction and deconstruction </a></li>
</ul>
</li>
<li><a href="#sec-3.3">3.3 Parameterized Types </a></li>
<li><a href="#sec-3.4">3.4 Exercise Solutions </a></li>
<li><a href="#sec-3.5">3.5 Errors </a></li>
<li><a href="#sec-3.6">3.6 Local variables </a></li>
<li><a href="#sec-3.7">3.7 The case expression </a></li>
<li><a href="#sec-3.8">3.8 Guards </a></li>
</ul>
</li>
<li><a href="#sec-4">4 Functional Programming </a>
<ul>
<li><a href="#sec-4.1">4.1 Objectives </a></li>
<li><a href="#sec-4.2">4.2 A simple command line framework </a></li>
</ul>
</li>
<li><a href="#sec-5">5 Writing a library - working with JSON data </a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Real World Haskell </h2>
<div class="outline-text-2" id="text-1">


<p>
This is a book that I attempted to go through once but then gave up
because of lack of time. But I guess I will finish going through it
this time. Also this book is available free online
<a href="http://book.realworldhaskell.org/">here</a>.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Types and functions </h2>
<div class="outline-text-2" id="text-2">



</div>

<div id="outline-container-2.1" class="outline-3">
<h3 id="sec-2.1"><span class="section-number-3">2.1</span> Why care about types </h3>
<div class="outline-text-3" id="text-2.1">


<ul>
<li>
<b>Every</b> expression in haskell has a type.
<ul>
<li>
The type of a value indicates the properties it shares with
other values of the same type.
</li>
</ul>
</li>
<li>
At the lowest level information is represented in the form of
plain bits types helps up build abstractions over that

</li>
</ul>
</div>

</div>

<div id="outline-container-2.2" class="outline-3">
<h3 id="sec-2.2"><span class="section-number-3">2.2</span> Haskell's type system </h3>
<div class="outline-text-3" id="text-2.2">

<ul>
<li>
Its <i>strong, static and inferred</i>

</li>
</ul>

</div>

<div id="outline-container-2.2.1" class="outline-4">
<h4 id="sec-2.2.1"><span class="section-number-4">2.2.1</span> Strong type </h4>
<div class="outline-text-4" id="text-2.2.1">

<ul>
<li>
Indicates the programs written in this language will not contain
the types of errors that occur by incorrectly passing around
object of the wrong type.
</li>
<li>
It does not allow automatic coercion of types from one form to
another. 
<ul>
<li>
As result it can help up catch subtle bugs.

</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2.2.2" class="outline-4">
<h4 id="sec-2.2.2"><span class="section-number-4">2.2.2</span> Static type </h4>
<div class="outline-text-4" id="text-2.2.2">

<ul>
<li>
This means that the compiler knows the types of the values of
the expressions during compile time.
<ul>
<li>
This is cool because the compiler can perform analysis and
figure out where we might have problems in the code.
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2.2.3" class="outline-4">
<h4 id="sec-2.2.3"><span class="section-number-4">2.2.3</span> Type infereence </h4>
<div class="outline-text-4" id="text-2.2.3">

<ul>
<li>
The Haskell compiler can automagically deduce the type of
expressions for us.
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-2.3" class="outline-3">
<h3 id="sec-2.3"><span class="section-number-3">2.3</span> What to expect from the type system </h3>
<div class="outline-text-3" id="text-2.3">



</div>

<div id="outline-container-2.3.1" class="outline-4">
<h4 id="sec-2.3.1"><span class="section-number-4">2.3.1</span> Some basic common types </h4>
<div class="outline-text-4" id="text-2.3.1">

<ul>
<li>
<code>Char</code> - represents unicode characters
</li>
<li>
<code>Bool</code> - Boolean
</li>
<li>
<code>Int</code> - Integer where size is based on integer macchine size
</li>
<li>
<code>Integer</code> - Arbitrary sized integer, not as efficient as <code>Ints</code>
</li>
<li>
<code>Double</code> - It is suggested to use this instead of <code>Float</code> as
peole are working to make this more efficent
</li>
</ul>
</div>

</div>

<div id="outline-container-2.3.2" class="outline-4">
<h4 id="sec-2.3.2"><span class="section-number-4">2.3.2</span> Function application </h4>
<div class="outline-text-4" id="text-2.3.2">

<ul>
<li>
It has higher precedence than anyother operator
</li>
<li>
Its left associative
</li>
</ul>
</div>

</div>

<div id="outline-container-2.3.3" class="outline-4">
<h4 id="sec-2.3.3"><span class="section-number-4">2.3.3</span> Lists </h4>
<div class="outline-text-4" id="text-2.3.3">

<ul>
<li>
Is a list of values where all the values have the same type
</li>
<li>
Concatenation operator: <code>++</code>
</li>
<li>
Cons operator: <code>:</code>
</li>
</ul>
</div>

</div>

<div id="outline-container-2.3.4" class="outline-4">
<h4 id="sec-2.3.4"><span class="section-number-4">2.3.4</span> Tuples </h4>
<div class="outline-text-4" id="text-2.3.4">

<ul>
<li>
Is a fixed size collection that can contains objects of many
different types.
</li>
<li>
A tuple with zero elements <code>()</code> is called a <i>unit</i> its similar
to void in C
</li>
</ul>
</div>

</div>

<div id="outline-container-2.3.5" class="outline-4">
<h4 id="sec-2.3.5"><span class="section-number-4">2.3.5</span> Exercise Solutions </h4>
<div class="outline-text-4" id="text-2.3.5">

<ul>
<li>
Bool
</li>
<li>
(\[[Char]\], Char)
</li>
<li>
[(Bool, \[[Char]\]]
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-2.4" class="outline-3">
<h3 id="sec-2.4"><span class="section-number-3">2.4</span> Functions over Lists and tuples </h3>
<div class="outline-text-3" id="text-2.4">


</div>

<div id="outline-container-2.4.1" class="outline-4">
<h4 id="sec-2.4.1"><span class="section-number-4">2.4.1</span> List Functions </h4>
<div class="outline-text-4" id="text-2.4.1">

<ul>
<li>
<code>take</code> takes two arguments an integer and a list and returns the
first n element from the list
</li>
<li>
<code>drop</code> - takes two arguments an integer and a list and returns
all but the first n elements from the list
</li>
</ul>
</div>

</div>

<div id="outline-container-2.4.2" class="outline-4">
<h4 id="sec-2.4.2"><span class="section-number-4">2.4.2</span> Tuple Functions </h4>
<div class="outline-text-4" id="text-2.4.2">

<ul>
<li>
<code>fst</code>, <code>snd</code> as the name suggest returns the first and second
values from a two element tuple.
</li>
</ul>
</div>

</div>

<div id="outline-container-2.4.3" class="outline-4">
<h4 id="sec-2.4.3"><span class="section-number-4">2.4.3</span> Function Types and purity </h4>
<div class="outline-text-4" id="text-2.4.3">

<ul>
<li>
Typically in haskell the type signatures of functions is written
as follows for example the type of the function say <code>lines</code> is
<code>String-&gt;[String]</code> which essentially means that the function
takes in one string argument and returns a list of strings.
</li>
<li>
<code>QUESTION</code> In the last line of the section the author mentions that
Haskell's type system prevents us from mixing up pure and impure
code. I thought it was because of haskell functional nature.

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-2.5" class="outline-3">
<h3 id="sec-2.5"><span class="section-number-3">2.5</span> Haskell source files and writing simple functions </h3>
<div class="outline-text-3" id="text-2.5">


</div>

<div id="outline-container-2.5.1" class="outline-4">
<h4 id="sec-2.5.1"><span class="section-number-4">2.5.1</span> Just what is a variable anyway </h4>
<div class="outline-text-4" id="text-2.5.1">

<ul>
<li>
A variable in haskell is a means of naming expressions rather
than a name give to a storage location in the memory
</li>
<li>
<i>Note about indentation</i> Expressions with the same level of
indentation continue the expression.
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-2.6" class="outline-3">
<h3 id="sec-2.6"><span class="section-number-3">2.6</span> Polymorphism in haskell </h3>
<div class="outline-text-3" id="text-2.6">

<ul>
<li>
When a function has <i>type variables</i> in its signature we call it
polymorphic. Type variable can be identified because usually they
are in lower case.
</li>
<li>
The type of polymorphism provided by haskell is called
<i>parametric polymorphism</i>. If a type contains type parameters we
say that it is a parameterized type or a polymorphic type. A
parametric type in Haskell is very similar to a generic type in java.
</li>
</ul>
</div>

</div>

<div id="outline-container-2.7" class="outline-3">
<h3 id="sec-2.7"><span class="section-number-3">2.7</span> Functions with more that one argument </h3>
<div class="outline-text-3" id="text-2.7">

<ul>
<li>
For example if we take a funciton like <code>drop</code> we see that its
type signature is <code>Int-&gt;[a]-&gt;[a]</code>. Since <code>-&gt;</code> is right
associative we can write the signature as <code>Int-&gt;([a]-&gt;[a])</code>, what
it essentially means is that every function in haskell takes in
one argument and returns a value, but in this case what we see is
that it takes an <code>Int</code> argument and returns a function of that
takes a list and returns a list.

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Data types and stream lining functions </h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3.1" class="outline-3">
<h3 id="sec-3.1"><span class="section-number-3">3.1</span> Defining new data types </h3>
<div class="outline-text-3" id="text-3.1">

<p>Defining new data types make coding quite safe for us cause we would
not pass in incorrect data to functions. This is essentially achieved
because by defining data types we force the haskell compiler to verify
our the data types in our code.
</p>
<p>
New data types are defined using the the data
keyword. This expressions defines the <b>type constructor</b> and the
<b>value constructor</b>.  We refer to the data types generated by    
using the name given by its type constructor and as the name suggests
we use a value  constructor to build values. But in most code it so
happens that <i>both</i> the value and type constructors have the same name
</p>
<p>
<i>Question</i>
</p><ul>
<li>
Firstly, why is the use of the value constructors so very
inconsistent, because when we use plain integers, or floats we don't
use it but we do use it for user defined types. So is that a reason
its there because its for user defined types.

</li>
</ul>

<p>So after reading further down I figured that, value constructors are
treated like functions. More details can be obtained using the 
<code>:info</code>
</p>

</div>

<div id="outline-container-3.1.1" class="outline-4">
<h4 id="sec-3.1.1"><span class="section-number-4">3.1.1</span> Type synonyms </h4>
<div class="outline-text-4" id="text-3.1.1">


<p>
Type synonyms are synonyms for existing data types. They serve the
purpose of making the existing code readable. They are created using
the <code>type</code> keyword
</p>
</div>

</div>

<div id="outline-container-3.1.2" class="outline-4">
<h4 id="sec-3.1.2"><span class="section-number-4">3.1.2</span> Algebraic Data types </h4>
<div class="outline-text-4" id="text-3.1.2">


<p>
Is a data type that has &lt;b&gt;more than one &lt;/b&gt; value constructor. They
are separated using the "|" character.
</p>
<p>
The point of using user defined data types over standard constructs
like tuples is when we have to clarify the types we are dealing with.
</p>
<p>
Types can be used to perform the roles of equivalent features provided
by other languages like structures, enumerations, unions.
</p>
</div>
</div>

</div>

<div id="outline-container-3.2" class="outline-3">
<h3 id="sec-3.2"><span class="section-number-3">3.2</span> Pattern Matching </h3>
<div class="outline-text-3" id="text-3.2">


<p>
Haskell provides a facility by which we can define functions are
series of equations what essentially is happening here is that at
Haskell performs run time checks and applies the appropriate
definition.
</p>

</div>

<div id="outline-container-3.2.1" class="outline-4">
<h4 id="sec-3.2.1"><span class="section-number-4">3.2.1</span> Construction and deconstruction </h4>
<div class="outline-text-4" id="text-3.2.1">

<ul>
<li>
We construct values of a give type by invoking its value constructor
</li>
<li>
We <i>deconstruct</i> a type by matching the value against a pattern
the pattern of the type.
</li>
<li>
We use the <code>_</code> to represent a wildcard, to indicate that we
don't care about a particular value
</li>
<li>
Something quite painful about the whole thing is that you have
to go on writing a bunch of accessors that can be quite a
pain. To get around that we have something called the record
syntax where can specify the names of the accessors of the field
immediately. 


</li>
</ul>


<pre class="src src-haskell"><span style="color: #00ffff;">data</span> <span style="color: #98fb98;">BookInfo</span> <span style="color: #eedd82;">=</span> <span style="color: #98fb98;">Book</span> {
      bookId <span style="color: #eedd82;">::</span> <span style="color: #98fb98;">Int</span>
    , bookName <span style="color: #eedd82;">::</span> <span style="color: #98fb98;">String</span>
    , authors <span style="color: #eedd82;">::</span> [<span style="color: #98fb98;">String</span>]
    } <span style="color: #00ffff;">deriving</span> (<span style="color: #98fb98;">Show</span>)
</pre>




<ul>
<li>
The part before the <code>::</code> is the name of the accessor and the
part after it is the type.
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3.3" class="outline-3">
<h3 id="sec-3.3"><span class="section-number-3">3.3</span> Parameterized Types </h3>
<div class="outline-text-3" id="text-3.3">

<ul>
<li>
We can create parameterized types by adding a type variable into
our type declarations


</li>
</ul>


<pre class="src src-haskell"><span style="color: #00ffff;">data</span> <span style="color: #98fb98;">Maybe</span> a <span style="color: #eedd82;">=</span> <span style="color: #98fb98;">Just</span> a
             <span style="color: #eedd82;">|</span> <span style="color: #98fb98;">Nothing</span>
</pre>



<ul>
<li>
Heck this is quite cool!
</li>
</ul>
</div>

</div>

<div id="outline-container-3.4" class="outline-3">
<h3 id="sec-3.4"><span class="section-number-3">3.4</span> Exercise Solutions </h3>
<div class="outline-text-3" id="text-3.4">

<ul>
<li>
Ex 1

</li>
</ul>


<pre class="src src-haskell"><span style="color: #87cefa;">fromList</span> <span style="color: #98fb98;">Nil</span> <span style="color: #eedd82;">=</span> <span style="color: #98fb98;">[]</span>
<span style="color: #87cefa;">fromList</span> (<span style="color: #98fb98;">Cons</span> x xs) <span style="color: #eedd82;">=</span> x <span style="color: #98fb98;">:</span> fromList xs
</pre>



<ul>
<li>
Ex 2

</li>
</ul>


<pre class="src src-haskell"><span style="color: #00ffff;">data</span> <span style="color: #98fb98;">Tree</span> a <span style="color: #eedd82;">=</span> <span style="color: #98fb98;">Node</span> a (<span style="color: #98fb98;">Maybe</span> (<span style="color: #98fb98;">Tree</span> a)) (<span style="color: #98fb98;">Maybe</span> (<span style="color: #98fb98;">Tree</span> a))  <span style="color: #00ffff;">deriving</span>
(<span style="color: #98fb98;">Show</span>)
</pre>



</div>

</div>

<div id="outline-container-3.5" class="outline-3">
<h3 id="sec-3.5"><span class="section-number-3">3.5</span> Errors </h3>
<div class="outline-text-3" id="text-3.5">

<ul>
<li>
We can use the <code>error</code> function in haskell to throw up an error
</li>
</ul>
</div>

</div>

<div id="outline-container-3.6" class="outline-3">
<h3 id="sec-3.6"><span class="section-number-3">3.6</span> Local variables </h3>
<div class="outline-text-3" id="text-3.6">

<ul>
<li>
Local variables can be defined using the <code>let...in...</code> statement
</li>
<li>
<code>let...in...</code> blocks can be nested, and if we have a variable in
an inner let block that has the same name as another then the
variable in the inner block <i>shadows</i> the varianble in the outer block
</li>
</ul>
</div>

</div>

<div id="outline-container-3.7" class="outline-3">
<h3 id="sec-3.7"><span class="section-number-3">3.7</span> The case expression </h3>
<div class="outline-text-3" id="text-3.7">

<p>=case variable of
pattern  -&gt; value
pattern -&gt; value
=
</p></div>

</div>

<div id="outline-container-3.8" class="outline-3">
<h3 id="sec-3.8"><span class="section-number-3">3.8</span> Guards </h3>
<div class="outline-text-3" id="text-3.8">

<ul>
<li>
Used for conditional evaluation
</li>
<li>
All expressions must be <code>Bool</code>
</li>
<li>
The variable <code>otherwise</code> is bound to <code>True</code>

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Functional Programming </h2>
<div class="outline-text-2" id="text-4">


</div>

<div id="outline-container-4.1" class="outline-3">
<h3 id="sec-4.1"><span class="section-number-3">4.1</span> Objectives </h3>
<div class="outline-text-3" id="text-4.1">

<ul>
<li>
Start thinking functionally
</li>
<li>
Find our way around the haskell library
</li>
</ul>
</div>

</div>

<div id="outline-container-4.2" class="outline-3">
<h3 id="sec-4.2"><span class="section-number-3">4.2</span> A simple command line framework </h3>
<div class="outline-text-3" id="text-4.2">

<ul>
<li>
Writing a simple program that copies from an input file to an
output file, by reading the file names from the input

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Writing a library - working with JSON data </h2>
<div class="outline-text-2" id="text-5">

<p>JSON has four basic types. Strings, numbers, booleans and a special
value called null.
</p>

</div>
</div>
<div id="postamble">
<p class="author"> Author: Reuben Francis Cornel
<a href="mailto:reuben@odin.local">&lt;reuben@odin.local&gt;</a>
</p>
<p class="date"> Date: 2011-08-28 23:28:36 PDT</p>
<p class="creator">HTML generated by org-mode 6.33x in emacs 23</p>
</div>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Reuben's Webpage</title>
<link rel="stylesheet" href="sitestyle.css" type="text/css" />
</head>
<body>

<div id="Header">
<center>
<h1>
Link List Tutorial
</h1>
</center>
</div>
<div class="content">
<h2>
Adding elements in the middle of a list
</h2>
<p>
Well, if you managed till here I must really applaud your
patience. This section might be a bit tough, but I will try and keep
it as simple as I can. 
</p><br />

<p>
As usual we start off by looking at some code. This time the program
actually does some useful work it is an insertion sort program. The
algorithm for insertion sort is really very simple. Our program
receives numbers one after another. We compare this number with the
numbers we have in a list and insert it in an appropriate
position. Though I must say this is not a very good sorting
algorithm, performance wise. The code can be downloaded <a
href="linklist4.c.txt">here</a>. 
<div id="navCode">
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#include&lt;stdio.h&gt;<br />
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this macro calculates the size of the array for us
<br />
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//for eg if you pass it 10 element array. In Linux
<br />
3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//sizeof(array) will be 40 bytes since 1 int in Linux is 4 bytes
<br />
4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Therefore size of array will be 40/4 =10 elements
<br />
5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#define NELEM(array) (sizeof(array)/sizeof(int))
<br />
6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct node{
<br />
7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  int n;
<br />
8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  struct node *next;
<br />
9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
<br />
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef struct node node;
<br />
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node *Insert(node *first,int number){
<br />
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  node *new_node=(node *)malloc(sizeof(node));
<br />
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  node *temp=first;
<br />
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  node *temp1=first;
<br />
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  new_node-&gt;n=number;<br />
18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  new_node-&gt;next=NULL;<br />
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(first==NULL){
<br />
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    first=new_node;
<br />
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return first;
<br />
23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }
<br />
24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for(;temp!=NULL;temp=temp-&gt;next){<br />
26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if(temp-&gt;n&gt;number){<br />
27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      for(;temp1-&gt;next!=temp;temp1=temp1-&gt;next);<br />
28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      break;
<br />
29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }
<br />
30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }
<br />
31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(temp==first){
<br />
33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    new_node-&gt;next=first;<br />
34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    first=new_node;
<br />
35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return first;
<br />
36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }
<br />
37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(temp==NULL){
<br />
39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    for(;temp1-&gt;next!=temp;temp1=temp1-&gt;next);<br />
40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    temp1-&gt;next=new_node;<br />
41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return first;
<br />
42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }
<br />
43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //insert element in the middle  
<br />
45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  new_node-&gt;next=temp;<br />
46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  temp1-&gt;next=new_node;<br />
47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return first;
<br />
48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the insertion sort function takes the first node pointer and 
<br />
51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//also the list of numbers to be sorted
<br />
52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node *InsertionSort(node *first,int list[],int n){
<br />
53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  int i=0;
<br />
54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for(i=0;i&lt;n;i++){<br />
56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    first=Insert(first,list[i]);
<br />
57&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }
<br />
58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return first;
<br />
59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void printList(node *first){
<br />
62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  node *temp=first;
<br />
63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  printf("List Contents:\n");
<br />
64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  while(temp!=NULL){
<br />
65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    printf("%d\n",temp-&gt;n);<br />
66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    temp=temp-&gt;next;<br />
67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }
<br />
68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int main(){
<br />
71&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  node *first=NULL;
<br />
72&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  int a[]={1,453,345,356,3,65,6,4645,4};
<br />
73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  first=InsertionSort(first,a,NELEM(a));
<br />
74&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  printList(first);
<br />
75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
</div></p><br />
<p>
Phew! That was some bit of code. But never fear when Reuben is
  near. We will take that apart part by part. If you do notice this
  program has made use of both the concept's I've explained till
  now. That is inserting elements in the beginning and inserting
  elements at the end.
</p><br />

</div>

<div class="content">
<h2>
The main function
</h2>
<p>
<div id="navCode">
76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int main(){
<br />
77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  node *first=NULL;
<br />
78&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  int a[]={1,453,345,356,3,65,6,4645,4};
<br />
79&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  first=InsertionSort(first,a,NELEM(a));
<br />
80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  printList(first);
<br />
81&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
</div></p><br />
<p>
This is simple all we do here is create a pointer to hold the list,
  then create an array to be sorted. Line 3 calls the sort
  function, and ofcourse you should know what Line 4 does by now.
</p><br />

</div>

<div class="content">
<h2>
The InsertionSort function
</h2>

<p>
The work of this function is simple it just goes through the array
    calling the insert function which inserts the element in the right
    position. 
</p><br />

</div>

<div class="content">
<h2>
The Insert function
</h2>
<div id="navCode">
82&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  node *new_node=(node *)malloc(sizeof(node));
<br />
83&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  node *temp=first;
<br />
84&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  node *temp1=first;
<br />
85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  new_node-&gt;n=number;<br />
87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  new_node-&gt;next=NULL;<br />
</div>
<p>
Now we have the juicy part. This is the function where all the action
happens. Let us start off by looking at the variables used.
At line 0 as usual we create a new node for the list and in line 4 and
  5 the assignment of the same happens. In line 1 we have the temp
  variable which is used to traverse the list. In line 2 we have the
  temp1 variable that is used to traverse the list once we have
  traversed the list. I'll explain that statement in a while.
</p><br />

<div id="navCode">
88&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(first==NULL){
<br />
89&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    first=new_node;
<br />
90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return first;
<br />
91&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }
<br />
92&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
</div><p>
The section of code above checks to see weather the element inserted
is the first one or not. If it is the first one then the first pointer
is made to point to it and the first pointer is returned.
</p><br />

<div id="navCode">
93&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for(;temp!=NULL;temp=temp-&gt;next){<br />
94&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if(temp-&gt;n&gt;number){<br />
95&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      for(;temp1-&gt;next!=temp;temp1=temp1-&gt;next);<br />
96&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      break;
<br />
97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }
<br />
98&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }
<br />
</div><p>
If we escape the above "if" construct unscathed we land in to this
weird looking for loop. This is a more compact way of traversing the
list. Since we already assigned temp to first in the begining of the
function we don't need to do it again. The condition for the loop is
that temp must not become NULL, and next part of the loop is the
actual traversal.
</p><br />
<p>
In the above code segment's if construct we check whether the number
stored in the node greater than the number entered. If that is the
case the we use the temp1 variable to traverse the list and stop in
the node before temp. Thats what I meant when I said temp1 is used
traverse the list once we have traversed the list.
Pictorially it can be shown as follows.
<br /><br />
<CENTER>
<img src="linklist41.png" alt="usage of temp1"/>
</CENTER>
</p><br />

<div id="navCode">
99&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(temp==first){
<br />
100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    new_node-&gt;next=first;<br />
101&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    first=new_node;
<br />
102&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return first;
<br />
103&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }
<br />
104&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
</div><p>

This section of code gets control when the while loop breaks. If it
happens that the temp points to the first node. The new node is
inserted at the begining of this list.
</p><br />

<div id="navCode">
105&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(temp==NULL){
<br />
106&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    for(;temp1-&gt;next!=temp;temp1=temp1-&gt;next);<br />
107&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    temp1-&gt;next=new_node;<br />
108&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return first;
<br />
109&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }
<br />
</div><p>
The code above should be obvious. If temp is pointing to NULL that
means that we are at the end of the list. Therefore, we insert the new
node at the end of the list.
</p><br />

<div id="navCode">
110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  new_node-&gt;next=temp;<br />
111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  temp1-&gt;next=new_node;<br />
112&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return first;
<br />
</div><p>
This is the intresting part. Here we insert the node in the middle of
the list. We make new_node point to temp. Once this is done we make
temp1's next pointer point to new_node. This is shown in the diagrams
below.<br /><br />
<CENTER>
<img src="linklist42.png" alt="in the middle of the list">
</CENTER>
<CENTER>
<img src="linklist43.png" alt="in the middle of the list">
</CENTER>
</p><br />
<p>
I think that all there is to the program once you have mastered this
section and the previous section you should be able to write simple
programs that make use of link lists. In the next few sections I will
be concentrating on removing elements from a link list.
</p><br />

</div>

<div id="navAlpha">
<a href="whats_new.html">Whats New</a><br /><br />
 <a href="aboutme.html">About Me</a><br /><br />
 <a href="cooking.html">Cooking</a><br /><br />
 <a href="photoalbum.html">Photos</a><br /><br />
 <a href="linklist.html">Link List Tutorial</a><br /><br />
 <a href="trouble_shooting.html">Trouble Shooting Linux</a><br /><br />
 <a href="page_script.html">Scripts used to Generate this Site</a><br /><br />
 <a href="project.html">My Projects</a><br /><br />
 <a href="misc.html">Miscellaneous</a><br /><br />
 <a href="unix_handouts.html">Unix Handouts</a><br /><br />
 <a href="index.html">Home Sweet Home</a><br /><br />
 </div>
<div id="navBeta">
<a href="linklist.html">Link List Tutorial Home</a><br /><br />
 <a href="needlinklist.html">Why do we need Link lists??</a><br /><br />
 <a href="enter_linklist.html">Enter The Link List</a><br /><br />
 <a href="in_front.html">Insert Elements in the Front of a List</a><br /><br />
 <a href="at_end.html">Insert Elements at the End of the List</a><br /><br />
 <a href="in_middle.html">Insert Elements in the Middle of the List</a><br /><br />
 </div>

</body>
</html>
